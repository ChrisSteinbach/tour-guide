What follows is a discussion of implementing nearest neighbour on the sphere using a Voronoi a graph approach to partitioning.

I want you to read through and suggest a plan for taking a stab at this. 

The eventual use case is a tour guide that takes current coordinates and then looks up a Wikipedia article (via the prevalent geographic coordinates in Wikipedia articles) based on nearest neighbour.

Naturally there are some different options presented, and I will leave to you to choose between them.

What follows is input to this, and an idea of where I want you to take it.

-----
Nearest Neighbor Search on the Sphere: Adapting Planar Algorithms to Geodesic Space

Introduction: Nearest-neighbor algorithms in computational geometry are well-studied for planar point sets. For example, the classic “post office problem” asks: given $n$ known points (e.g. post offices) on a plane, how can we preprocess them so that for any query location we can quickly find the nearest point? Solutions often involve constructing a Voronoi diagram – a partition of the plane into regions where each region consists of all locations closest to one particular site. The query then reduces to determining which Voronoi region the point lies in, which directly gives the nearest neighbor. Our goal is to move this math and algorithmic approach to a sphere, so that we can perform nearest-neighbor queries on Earth’s surface (using great-circle distances). This is highly relevant for a “closest attraction” tour-guide use case, where we might have many points of interest (attractions) given by latitude/longitude and need to efficiently find which one is closest to a user’s current location on the globe. In the discussion below, we outline the theoretical foundations of planar Voronoi-based nearest neighbor methods and then describe how to extend these concepts to spherical geometry, highlighting efficiency and implementation considerations (without relying on existing geospatial libraries).

Voronoi-Based Nearest Neighbor in the Plane

Voronoi diagrams and their dual, Delaunay triangulations, form the backbone of many efficient planar nearest-neighbor algorithms. In the planar case, the nearest-neighbor query problem (the “post office problem”) can be solved in optimal time by first computing the Voronoi diagram of the $n$ given sites. The Voronoi diagram partitions the plane into polygonal regions, each region containing all points closer to one particular site than to any other. Once this diagram is built, answering a query is a point-location task: determine which region contains the query point $x$, and output the associated site as the nearest neighbor. A straightforward point-location approach uses the so-called “slab method” (attributed to Dobkin and Lipton): one draws horizontal lines through every Voronoi vertex, partitioning the diagram into horizontal slabs (strips). Within each slab, the Voronoi edges are $x$-monotonic and can be ordered. To locate a query $(x_1, x_2)$, one first does a binary search on $x_2$ to find the correct slab, then a binary search on $x_1$ among the ordered edges in that slab. This yields an $O(\log n)$ query time, although the slab method as described uses quadratic storage (because of all the additional horizontal lines and subdivision).

Modern computational geometry offers more efficient point-location structures that reduce storage to linear. For example, Kirkpatrick’s hierarchical triangulation refinement or the method of Edelsbrunner et al. can preprocess the Voronoi diagram into a point-location data structure in linear space, while retaining $O(\log n)$ query time. Combining such a structure with an optimal $O(n \log n)$ algorithm to build the Voronoi diagram in the first place, we get the classical result:

> Planar nearest-neighbor queries: Given $n$ point sites in the plane, one can, in $O(n \log n)$ time and $O(n)$ space, preprocess them into a structure that answers nearest-neighbor queries in $O(\log n)$ time.



In other words, if we ignore constant factors, this is as efficient as it can get (since even just reading the input or writing the output takes $O(n)$ or $O(\log n)$ time respectively). The Voronoi diagram is the locus-based solution (partitioning space into nearest-neighbor regions), and these optimal structures are essentially using the Voronoi graph for fast queries. In practice, one could also build a Delaunay triangulation of the points (which is the planar dual of the Voronoi diagram) in $O(n \log n)$ time, and then answer queries by walking through the triangulation or using a point-location structure on the triangulation – this is conceptually similar since the Delaunay graph contains the same neighbor relationships.

A related problem is the “all nearest neighbors” problem: finding, for each of the $n$ points, the closest other point. This problem can also be solved efficiently by exploiting the Voronoi/Delaunay structure. It is known that in a planar point set, if two points are mutual nearest neighbors, their Voronoi regions will share a boundary segment. Equivalently, each point’s nearest neighbor must be one of the points adjacent to it in the Delaunay triangulation. (Intuitively, if some other farther point were the nearest, that nearer neighbor’s region would have to touch.) The Delaunay triangulation in the plane has a linear number of edges (about $3n$ edges for $n$ points, if in general position), and each point has on average 6 neighbors in the triangulation. Thus, to find each point’s nearest neighbor, one can: (1) compute the Delaunay triangulation in $O(n \log n)$ time; (2) for each point, inspect all its Delaunay-adjacent neighbors (a constant-time operation on average) to find the minimum distance. This yields all nearest-neighbor pairs in overall $O(n \log n)$ time. The resulting directed graph of nearest-neighbor pairs (each point has an arrow to its closest neighbor) is known as the nearest neighbor graph, which in the planar case is a collection of disjoint directed trees (each point has out-degree 1, and in-degree up to 6 in general position). This fact might not be directly used in a tour-guide scenario, but it underscores how Voronoi/Delaunay methods also efficiently handle bulk nearest-neighbor computations. The key takeaway is that Voronoi diagrams/Delaunay triangulations provide an efficient way to solve nearest-neighbor problems in the plane, both for single queries and for finding all pairs, with optimal time complexity.

Adapting Nearest-Neighbor Algorithms to the Sphere

When we move from a flat plane to a spherical surface (modeling Earth as a sphere for geographical coordinates), the fundamental definitions remain analogous: we consider distances along the surface (great-circle distances on the sphere), and we want to partition the surface into regions of influence of each site. A spherical Voronoi diagram of a set of points on the sphere is defined such that each region consists of the set of locations on the sphere closer to a particular generator point than to any other. In other words, for $N$ points on a sphere, the Voronoi diagram covers the whole spherical surface with $N$ cells, each cell being a (spherical) polygon on the surface. Every point on the sphere lies in the Voronoi region of the geographically nearest site. The dual of this structure is a spherical Delaunay triangulation, which connects points with arcs (great-circle segments) such that no point lies inside the “circumcircle” of any triangle. Here circumcircle on a sphere means the unique great-circle or small-circle passing through the three vertices of the triangle – the Delaunay condition is that each of those circles contains no other input points in its interior. These concepts mirror the planar case, just projected onto a curved surface.

The good news is that much of the planar Voronoi theory carries over to the sphere, with appropriate modifications. In fact, there is a deep connection between spherical Voronoi diagrams and 3D convex hulls: if you take the given points on the unit sphere and consider them as points in 3D space, the convex hull of those points (in $\mathbb{R}^3$) is closely related to the spherical Delaunay triangulation. Specifically, a classic result by Brown (and others) showed that the combinatorial structure of the spherical Voronoi diagram is identical to the structure of the convex hull of the points in 3D. Every facet of the 3D convex hull corresponds to an “empty circle” on the sphere, and thus to a Voronoi vertex (where three or more Voronoi regions meet). This implies that one way to compute a spherical Delaunay triangulation is: compute the convex hull of the $N$ points in 3D (which takes $O(N \log N)$ time), then project those hull facets back onto the sphere – effectively yielding the Delaunay triangles on the sphere. Indeed, by leveraging this connection or adapting planar algorithms, one can construct the spherical Delaunay/Voronoi in $O(N \log N)$ time, parallel to the planar complexity. For example, Algorithm 772: STRIPACK by Renka is a published library that performs Delaunay triangulation on the unit sphere using an incremental insertion approach, achieving $O(N \log N)$ construction time in practice. The resulting data structure provides each point’s neighbors on the sphere (adjacent in the triangulation) and can optionally output the Voronoi cells as well.

Just as in the plane, the spherical Voronoi diagram can directly solve nearest-neighbor queries in theory. Given a query location on the sphere (specified by latitude/longitude or as an $(x,y,z)$ unit vector), if we can determine which spherical Voronoi region contains that point, we immediately know which site is closest. The challenge is performing this point location on a spherical partition efficiently. Planar point-location methods like the slab method relied on a global coordinate (y-coordinate to choose a slab, x-coordinate within it). On a sphere, we don’t have straight horizontal lines, but we can use analogous constructs. For instance, one could draw circles of constant latitude (horizontal rings on the globe) through each Voronoi vertex – these would partition the sphere into bands where the structure within each band is simpler (no Voronoi vertices lie strictly inside a band). Within each band, the boundaries of the Voronoi regions (which are portions of great-circle arcs) would be monotonic in the north-south direction, so one could do a similar two-stage search (find the latitude band, then find the region within that band). Conceptually this is similar to the slab method idea, though the details get complicated by the curvature. Nonetheless, with proper data structures, one can achieve $O(\log N)$ point-location on the spherical Voronoi diagram as well, using $O(N)$ or so storage, analogous to the planar case. (In fact, since the sphere has finite area and no “infinite” unbounded regions, point location can be made quite elegant by hierarchical subdivision of the sphere.)

Another approach is to use the spherical Delaunay triangulation for queries. Given the Delaunay triangulation of the $N$ points on the sphere, we can answer a nearest-neighbor query by locating which Delaunay triangle (face) the query point falls into on the sphere – the query point will be closest to the vertex of that triangle whose Voronoi region covers the query. Renka’s STRIPACK library, for example, provides a function to locate a point relative to a spherical triangulation (i.e. find which triangular cell contains a given point). If one has fast access to an initial triangle near the query, one can “walk” through the triangulation: from a starting triangle, check its neighbors in the direction of the query point until the triangle containing the point is reached. In planar triangulations, this walk is expected to take $O(n^{1/2})$ steps in worst-case but often much less if the starting point is chosen well; on a sphere (which is topologically similar to a planar graph), similar considerations apply. There are also more sophisticated point-location methods on triangulations (e.g. using jump-and-walk or building an acceleration structure in $O(N)$ space for $O(\log N)$ queries). The bottom line is that once you have the spherical Voronoi or Delaunay structure, answering nearest-neighbor queries is efficient, on the order of logarithmic time or even constant-time on average with appropriate methods.

For the “all nearest neighbors” problem on the sphere (i.e. find each point’s nearest neighbor among the set), the situation parallels the planar case. If we have the spherical Delaunay triangulation, each point’s nearest neighbor will be one of its Delaunay-adjacent neighbors on the sphere. We can determine each point’s nearest neighbor by scanning its connected neighbors (which are usually a fixed small number). Planar results indicated each point has at most 6 Delaunay neighbors on average (often exactly 5-6 for large $N$); on a spherical triangulation, a similar property holds (Euler’s formula for planar graphs on the sphere constrains the average degree of a node in a triangulation to $< 6$). Thus, after $O(N \log N)$ time building the triangulation, we can obtain all nearest-neighbor pairs in $O(N)$ additional time. Moreover, a theoretical lemma analogous to the planar case can be stated: if $p$ and $q$ are a pair of points on the sphere such that $q$ is the closest point to $p$ (and vice versa), then $p$ and $q$ will share a Voronoi boundary segment (their Voronoi cells touch each other) and hence are connected by a Delaunay edge on the sphere. This is intuitively true because if $p$ and $q$ are mutual nearest neighbors, any point on the geodesic (great-circle) segment between them is closer to $p$ or $q$ than to any other site, which implies that segment lies on the boundary of their Voronoi regions. All these correspondences confirm that the Voronoi/Delaunay framework is valid on a sphere just as in the plane, enabling efficient nearest-neighbor computation on the sphere using similar algorithms.

One thing to keep in mind is that distance on a sphere is a metric that is closely related to Euclidean distance in 3D. In fact, for points on a fixed-radius sphere, the great-circle distance (geodesic distance) is a monotonic function of the straight-line Euclidean distance between the points (through the Earth). This means if a point $A$ is closer to a query $Q$ in terms of great-circle distance than another point $B$ is, then $A$ is also closer to $Q$ than $B$ is in terms of ordinary Euclidean distance in $\mathbb{R}^3$. This observation is useful because it means we can sometimes simplify computations by using the 3D coordinates of points on the unit sphere: the nearest neighbor in great-circle terms is also the nearest in terms of the chord distance through the sphere’s interior. We will use this fact in implementation strategies below.

Efficient Implementation Pointers (Geodesic Nearest-Neighbor in Code)

Designing a nearest-neighbor algorithm for geographical coordinates from scratch means we need to handle spherical geometry carefully while keeping efficiency in focus. Here are some key considerations and strategies for implementation:

Coordinate Representation & Distance Calculation: Rather than doing all calculations in latitude-longitude (which can be awkward due to the singularity at the poles and the $360^\circ$ wrap-around in longitude), it’s often convenient to convert points to 3D Cartesian coordinates on the unit sphere. Represent each point by its $(x,y,z)$ coordinates (with $x^2+y^2+z^2=1$). This makes certain geometric operations easier: for example, the great-circle distance between two points can be computed via the dot product (if $\mathbf{a}$ and $\mathbf{b}$ are unit vectors, $\mathbf{a}\cdot\mathbf{b} = \cos \theta$ where $\theta$ is the central angle between them). You can use the dot product to compute distances or the haversine formula in lat-long directly – both are fine. The 3D representation also simplifies checks like “which side of a great-circle boundary is a point on?” using cross products (the sign of the triple product can tell you if a point lies to the left or right of a great-circle arc). Be mindful of floating-point precision; double precision is recommended for safety, especially if points are very close to each other (tiny distance differences can be significant in determining nearest neighbors).

Building a Spherical Delaunay/Voronoi: If you choose the Voronoi-based approach (which is attractive for theoretical optimality), you’ll need to construct the spherical Delaunay triangulation of the input points. One way is to implement a spherical incremental Delaunay algorithm. This could work as follows: start with an initial “base” triangulation of, say, 4 points that form a tetrahedron covering the sphere (or even two antipodal points and two more to make initial triangles). Then, insert points one by one. For each new point, find the triangle (or triangles) it falls in, and perform a “cavity” re-triangulation: remove all triangles whose circumcircle (on the sphere) contains the new point, and re-triangulate the exposed hole by connecting the new point to the boundary of that hole. This is a direct analog of the Bowyer-Watson algorithm on the plane, extended to spherical geometry. The main geometric test needed is: does a point lie inside the spherical circumcircle of a triangle? In practice, you can determine this by checking the oriented volume of the tetrahedron formed by the three triangle vertices and the candidate point – a method used in 3D convex hull algorithms. (Alternatively, find the circle’s center by computing the intersection of the perpendicular bisector planes of the three edges, then check the distance from that center to the candidate point.) Renka’s STRIPACK uses a variant of Lawson’s flip algorithm: it maintains a triangulation and locally flips edges to restore the Delaunay condition after each insertion. Implementing this from scratch is non-trivial but certainly doable with careful attention to geometry. The result will be a data structure (perhaps an adjacency list of which points connect to which) representing the triangulation. From there, you can derive the Voronoi diagram if needed (by finding circumcenters of each triangle face, which will be points on the sphere equidistant from the triangle’s three defining sites). Another implementation route, as mentioned, is to leverage a 3D convex hull algorithm: use an existing convex hull method (or write one) to compute the convex hull of all points interpreted in 3D. Each face of this convex hull corresponds to either a Delaunay triangle on the sphere or a polygon that can be further triangulated. This method naturally gives you the Delaunay triangulation in $O(N \log N)$ time. However, be cautious: if all your points lie on a small portion of the sphere (say, a single hemisphere), then the convex hull of those 3D points will have a large face that is not actually part of the spherical Delaunay (it corresponds to the “outside” empty half-sphere). In such cases, you may need to add some “far” points or otherwise cap the hull. One trick is to add two artificial points at the north and south pole if your data doesn’t already span the globe; this forces the convex hull to include those and avoids a giant facet. You would then remove any triangulations involving these artificial points afterward. In summary, constructing the spherical Delaunay/Voronoi is analogous to the planar case and can be done in optimal $O(N \log N)$ time; the main difference is the geometry of the in-circle test and managing the spherical topology (no planar “infinite face” – the sphere is closed).

Query Data Structures (Spatial Indexing): If the number of query operations is large, you’ll want a fast way to go from a query point to its nearest site. Building the full spherical Voronoi diagram and doing point location on it is one approach, but there are simpler data structures too:

A KD-tree can be adapted to spherical data. One simple method is to treat the 3D coordinates $(x,y,z)$ of points on the unit sphere and build a standard 3-dimensional KD-tree (which splits points by x, y, z median values alternately). Because of the monotonic relationship between Euclidean distance in $\mathbb{R}^3$ and spherical distance on the surface, the nearest neighbor in the KD-tree under the usual Euclidean metric will in fact be the nearest in the spherical metric as well. The KD-tree gives average
